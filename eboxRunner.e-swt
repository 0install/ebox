println("E initialised")

def makeTraceln := <unsafe:org.erights.e.elib.debug.makeTraceln>
def makeELoader := <elang:interp.ELoaderAuthor>(makeTraceln)

def [json] := interp.getArgs()

def jsonSurgeon := <elib:serial.deJSONKit>.makeSurgeon()
def launchData := jsonSurgeon.unserialize(json)
def [ => locations, => dependencies, => args, => mainURI, => main, => instancePath ] := launchData

def <instance> := <file>[instancePath]
def petName := <instance>.getName()

# Create a loader for each module...

# URI -> (promise, resolver)
def loaders := [].asMap().diverge()
for uri => path in locations {
	loaders[uri] := Ref.promise()
}

for uri => deps in dependencies {
	def loader
	def envExtras := ["this__uriGetter" => loader].diverge()
	for [name, dep_iface] in deps {
		envExtras[`${name}__uriGetter`] := loaders[dep_iface][0]
	}
	def rx`.*/(@{leaf}[^/]+)` := uri
	traceln(`new loader $leaf from $uri with $envExtras`)
	bind loader := makeELoader(<file:/>[locations[uri]], envExtras.snapshot(), `$leaf$$`)
	loaders[uri][1].resolve(loader)
}

def powerbox {
	to openShell(title) {
		# Open the main window
		def <widget> := <swt:widgets.*>
		def shell := <widget:makeShell>(currentDisplay)
		def shellFacet extends shell {
			to setText(title :String) {
				super.setText(`$petName: $title`)
			}
		}
		shellFacet.setText(title)
		shell.open()
		return shellFacet
	}
}

def eParser := <elang:syntax.makeEParser>
def defaultAuthsCode := eParser(<instance:defaultAuths.e>.getTwine())
def defaultAuths := defaultAuthsCode.eval(privilegedScope.with([=> <instance>, => powerbox])).diverge()

def makeScope := <unsafe:org.erights.e.elang.scope.makeScope>
def topScope := makeScope.fromState(safeScope.getState() | defaultAuths, "top$")

println("Starting...")
loaders[mainURI][0].getWithBase(main, topScope)
